#include <stdio.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <unistd.h>
#include <arpa/inet.h>

#define MAXBUF 1024
int main(int argc, char **argv)
{
	int sockfd = 0;
	int newfd = 0;
	

	if (argc <3)
	{
		return -1;
	}

	int nPort = atoi(argv[1]);		//æŒ‡å®šç›‘å¬ç«¯å£
	int nListnum = atoi(argv[2]);	//æœ€å¤§å®¢æˆ·ç«¯è¿æ¥æ•?

	/* SSL åº“åˆå§‹åŒ–*/
	SSL_library_init();

	/* è½½å…¥æ‰€æœ‰SSL ç®—æ³•*/
	OpenSSL_add_all_algorithms();

	/* è½½å…¥æ‰€æœ‰SSL é”™è¯¯æ¶ˆæ¯*/
	SSL_load_error_strings();

	/* ä»¥SSL V2 å’ŒV3 æ ‡å‡†å…¼å®¹æ–¹å¼äº§ç”Ÿä¸€ä¸ªSSL_CTX ï¼Œå³SSL Content Text */
	SSL_CTX *ctx = SSL_CTX_new(SSLv23_client_method());
	/*
	ä¹Ÿå¯ä»¥ç”¨SSLv2_server_method() æˆ–SSLv3_server_method() å•ç‹¬è¡¨ç¤ºV2 æˆ–V3æ ‡å‡†
	*/

	if (NULL == ctx)
	{
		ERR_print_errors_fp(stdout);
		exit(1);
	}

	/* è½½å…¥ç”¨æˆ·çš„æ•°å­—è¯ä¹¦ï¼Œ æ­¤è¯ä¹¦ç”¨æ¥å‘é€ç»™å®¢æˆ·ç«¯ã€‚è¯ä¹¦é‡ŒåŒ…å«æœ‰å…¬é’?/
	if (SSL_CTX_use_certificate_file(ctx, argv[4], SSL_FILETYPE_PEM) <= 0)
	{
		ERR_print_errors_fp(stdout);
		exit(1);
	}
	/* è½½å…¥ç”¨æˆ·ç§é’¥*/
	if (SSL_CTX_use_PrivateKey_file(ctx, argv[5], SSL_FILETYPE_PEM) <= 0)
	{
		ERR_print_errors_fp(stdout);
		exit(1);
	}
	/* æ£€æŸ¥ç”¨æˆ·ç§é’¥æ˜¯å¦æ­£ç¡?/
	if (!SSL_CTX_check_private_key(ctx))
	{
		ERR_print_errors_fp(stdout);
		exit(1);
	}
	/* å¼€å¯ä¸€ä¸ªsocket ç›‘å¬*/
	int nSocket = socket(AF_INET, SOCK_STREAM, 0);
	if (nSocket == -1)
	{
		perror("socket error!\n");
		exit(1);
	}
	else
	{
		printf("socket created\n");
	}

	struct sockaddr_in my_addr = { 0 };
	struct sockaddr_in their_addr = { 0 };
	bzero(&my_addr, sizeof(my_addr));
	my_addr.sin_family = AF_INET;
	my_addr.sin_port = htons(nPort);
	//è®¾ç½®ç›‘å¬çš„IP
// 	if (argv[3])
// 	{
// 		my_addr.sin_addr.s_addr = inet_addr(argv[3]);
// 	}
// 	else
// 	{
// 		//å¦‚æœç”¨æˆ·æ²¡æœ‰æŒ‡å®šç›‘å¬ç«¯å£ï¼Œåˆ™é»˜è®¤ç›‘å¬0.0.0.0(ä»»æ„IP)
// 		my_addr.sin_addr.s_addr = INADDR_ANY;
// 	}
	my_addr.sin_addr.s_addr = inet_addr(argv[3]);

	if (bind(nSocket, (struct sockaddr *) &my_addr, sizeof(struct sockaddr)) == -1)
	{
		perror("bind");
		exit(1);
	}
	else
	{
		printf("binded\n");
	}
	if (listen(nSocket, nListnum) == -1)
	{
		perror("listen");
		exit(1);
	}
	else
	{
		printf("begin listen\n");
	}


	while (1)
	{
		SSL * ssl;
		socklen_t len = sizeof(struct sockaddr);
		/* ç­‰å¾…å®¢æˆ·ç«¯è¿ä¸Šæ¥*/
		int newfd = 0;
		if ((newfd = accept(nSocket, (struct sockaddr *)&their_addr, &len)) == -1)
		{
			perror("accept");
			exit(errno);
		}
		else
		{
			printf("server: got connection from %s, port %d, socket %d\n", inet_ntoa(their_addr.sin_addr), ntohs(their_addr.sin_port), newfd);
		}
		/* åŸºäºctx äº§ç”Ÿä¸€ä¸ªæ–°çš„SSL */
		ssl = SSL_new(ctx);
		/* å°†è¿æ¥ç”¨æˆ·çš„socket åŠ å…¥åˆ°SSL */
		SSL_set_fd(ssl, newfd);
		/* å»ºç«‹SSL è¿æ¥*/
		if (SSL_accept(ssl) == -1)
		{
			perror("accept");
			close(newfd);
			break;
		}
		/* å¼€å§‹å¤„ç†æ¯ä¸ªæ–°è¿æ¥ä¸Šçš„æ•°æ®æ”¶å‘*/
		char buf[MAXBUF + 1] = { 0 };
		bzero(buf, MAXBUF + 1);
		strcpy(buf, "server->client");
		/* å‘æ¶ˆæ¯ç»™å®¢æˆ·ç«?*/
		len = SSL_write(ssl, buf, strlen(buf));
		do
		{
			if (len <=0)
			{
				printf("æ¶ˆæ¯'%s'å‘é€å¤±è´¥ï¼é”™è¯¯ä»£ç æ˜?dï¼Œé”™è¯¯ä¿¡æ¯æ˜¯'%s'\n", buf, errno, strerror(errno));
				break;
			}
			else
			{
				printf("æ¶ˆæ¯'%s'å‘é€æˆåŠŸï¼Œå…±å‘é€äº†%d ä¸ªå­—èŠ‚ï¼\n", buf, len);
			}

			bzero(buf, MAXBUF + 1);
			/* æ¥æ”¶å®¢æˆ·ç«¯çš„æ¶ˆæ¯*/
			len = SSL_read(ssl, buf, MAXBUF);
			if (len > 0)
			{
				printf("æ¥æ”¶æ¶ˆæ¯æˆåŠŸ:'%s'ï¼Œå…±%d ä¸ªå­—èŠ‚çš„æ•°æ®\n", buf, len);
			}
			else
			{
				printf("æ¶ˆæ¯æ¥æ”¶å¤±è´¥ï¼é”™è¯¯ä»£ç æ˜¯%dï¼Œé”™è¯¯ä¿¡æ¯æ˜¯'%s'\n", errno, strerror(errno));
			}

		} while (0);
		/* å¤„ç†æ¯ä¸ªæ–°è¿æ¥ä¸Šçš„æ•°æ®æ”¶å‘ç»“æ?/
		/* å…³é—­SSL è¿æ¥*/
		SSL_shutdown(ssl);
		/* é‡Šæ”¾SSL */
		SSL_free(ssl);
		/* å…³é—­socket */
		close(newfd);
	}

	/* å…³é—­ç›‘å¬çš„socket */
	close(nSocket);
	/* é‡Šæ”¾CTX */
	SSL_CTX_free(ctx);

	return 0;
}